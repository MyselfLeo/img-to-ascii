use image::GenericImageView;
use std::env;


const SYMBOLS: [char; 5] = [' ', '░', '▒', '▓', '█'];
const MAX_WIDTH: u32 = 100;





struct AsciiImage {
    dimensions: (u32, u32),
    characters: Vec<char>
}

impl AsciiImage {
    fn print(&self) {
        for y in 0..self.dimensions.1 {
            if y % 2 == 0 {
                for x in 0..self.dimensions.0 {
                    print!("{}", self.characters[(x * self.dimensions.1 + y) as usize]);
                }
                print!("\n");
            }
        }
    }
}




fn get_output_dimensions(img_dimensions: (u32, u32)) -> (u32, u32) {
    // Return the dimensions of the outputed ascii image, as its width cannot be greater than MAX_WIDTH.

    if img_dimensions.0 > MAX_WIDTH {
        let ratio = MAX_WIDTH as f64 / img_dimensions.0 as f64; // an image of 1000w converted to 100w => ratio = 0.10
        println!("[INFO] Ratio <1: {}", ratio);
        return (MAX_WIDTH, (img_dimensions.1 as f64 * ratio) as u32);
    }
    else {
        return img_dimensions;
    }
}





fn convert_file(filepath: &String) -> AsciiImage {
    // Load image
    let mut image = image::open(filepath).expect("[ERROR] Unable to load the image.");
    let dimensions = image.dimensions();
    println!("[INFO] Image dimensions: {:?}", dimensions);

    // Compute output dimensions
    let output_dimensions = get_output_dimensions(dimensions);
    println!("[INFO] Output dimensions will be: {:?}", output_dimensions);

    // Create AsciiImage struct
    let mut ascii_image = AsciiImage{
        dimensions: output_dimensions,
        characters: Vec::new(),
    };

    // Convert the image to greyscale
    image = image.grayscale();
    let ratio = dimensions.0 / output_dimensions.0; // an image of 1000w converted to 100w => ratio = 10
    println!("[INFO] Ratio >1: {}", ratio);

    for x in 0..output_dimensions.0 {
        for y in 0..output_dimensions.1 {
            let pixel = image.get_pixel(x * ratio, y * ratio);
            let average = (pixel[0] as f64 + pixel[1] as f64 + pixel[2] as f64) / 3 as f64;

            // This code was generated by autopilot. Thank you autopilot, very cool.
            ascii_image.characters.push(SYMBOLS[(average / (255 as f64 / (SYMBOLS.len() - 1) as f64)) as usize]);
        }
    }

    return ascii_image;
}





fn main() {
    // Get file name from args
    let args: Vec<String> = env::args().collect();
    let mut filepath: &String = &String::new();
    match args.len() {
        1 => println!("[ERROR]] Please enter a valid path to the image."),
        _ => {filepath = &args[1];}
    }

    // Convert file
    let ascii_image = convert_file(filepath);

    ascii_image.print();
}
